"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  AlreadyExistsError: () => AlreadyExistsError,
  AuthenticatedClient: () => AuthenticatedClient,
  BreakingChangesError: () => BreakingChangesError,
  Client: () => Client2,
  ForbiddenError: () => ForbiddenError,
  InternalError: () => InternalError,
  InvalidDataFormatError: () => InvalidDataFormatError,
  InvalidIdentifierError: () => InvalidIdentifierError,
  InvalidJsonSchemaError: () => InvalidJsonSchemaError,
  InvalidPayloadError: () => InvalidPayloadError,
  InvalidQueryError: () => InvalidQueryError,
  LimitExceededError: () => LimitExceededError,
  MethodNotFoundError: () => MethodNotFoundError,
  PayloadTooLargeError: () => PayloadTooLargeError,
  PaymentRequiredError: () => PaymentRequiredError,
  QuotaExceededError: () => QuotaExceededError,
  RateLimitedError: () => RateLimitedError,
  ReferenceConstraintError: () => ReferenceConstraintError,
  ReferenceNotFoundError: () => ReferenceNotFoundError,
  RelationConflictError: () => RelationConflictError,
  ResourceNotFoundError: () => ResourceNotFoundError,
  RuntimeError: () => RuntimeError,
  SignalListener: () => SignalListener,
  UnauthorizedError: () => UnauthorizedError,
  UnknownError: () => UnknownError,
  UnsupportedMediaTypeError: () => UnsupportedMediaTypeError,
  axios: () => axios3,
  errorFrom: () => errorFrom,
  isApiError: () => isApiError
});
module.exports = __toCommonJS(src_exports);
var axios3 = __toESM(require("axios"));

// src/gen/client/errors.ts
var import_crypto = __toESM(require("crypto"));
var cryptoLibPolyfill = {
  getRandomValues: (array) => new Uint8Array(array.map(() => Math.floor(Math.random() * 256)))
};
var cryptoLib = typeof window !== "undefined" && typeof window.document !== "undefined" ? window.crypto : import_crypto.default;
if (!cryptoLib.getRandomValues) {
  cryptoLib = cryptoLibPolyfill;
}
var BaseApiError = class extends Error {
  constructor(code, description, type, message, error, id) {
    super(message);
    this.code = code;
    this.description = description;
    this.type = type;
    this.message = message;
    this.error = error;
    this.id = id;
    if (!this.id) {
      this.id = BaseApiError.generateId();
    }
  }
  isApiError = true;
  format() {
    return `[${this.type}] ${this.message} (Error ID: ${this.id})`;
  }
  toJSON() {
    return {
      id: this.id,
      code: this.code,
      type: this.type,
      message: this.message
    };
  }
  static generateId() {
    const prefix = this.getPrefix();
    const timestamp = new Date().toISOString().replace(/[\-:TZ]/g, "").split(".")[0];
    const randomSuffixByteLength = 4;
    const randomHexSuffix = Array.from(cryptoLib.getRandomValues(new Uint8Array(randomSuffixByteLength))).map((x) => x.toString(16).padStart(2, "0")).join("").toUpperCase();
    return `${prefix}_${timestamp}x${randomHexSuffix}`;
  }
  static getPrefix() {
    if (typeof window !== "undefined" && typeof window.document !== "undefined") {
      return "err_bwsr";
    }
    return "err";
  }
};
var isObject = (obj) => typeof obj === "object" && !Array.isArray(obj) && obj !== null;
var isApiError = (thrown) => {
  return thrown instanceof BaseApiError || isObject(thrown) && thrown.isApiError === true;
};
var UnknownError = class extends BaseApiError {
  constructor(message, error, id) {
    super(500, "An unknown error occurred", "Unknown", message, error, id);
  }
};
var InternalError = class extends BaseApiError {
  constructor(message, error, id) {
    super(500, "An internal error occurred", "Internal", message, error, id);
  }
};
var UnauthorizedError = class extends BaseApiError {
  constructor(message, error, id) {
    super(401, "The request requires to be authenticated.", "Unauthorized", message, error, id);
  }
};
var ForbiddenError = class extends BaseApiError {
  constructor(message, error, id) {
    super(403, "The requested action can't be peform by this resource.", "Forbidden", message, error, id);
  }
};
var PayloadTooLargeError = class extends BaseApiError {
  constructor(message, error, id) {
    super(413, "The request payload is too large.", "PayloadTooLarge", message, error, id);
  }
};
var InvalidPayloadError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The request payload is invalid.", "InvalidPayload", message, error, id);
  }
};
var UnsupportedMediaTypeError = class extends BaseApiError {
  constructor(message, error, id) {
    super(415, "The request is invalid because the content-type is not supported.", "UnsupportedMediaType", message, error, id);
  }
};
var MethodNotFoundError = class extends BaseApiError {
  constructor(message, error, id) {
    super(405, "The requested method does not exist.", "MethodNotFound", message, error, id);
  }
};
var ResourceNotFoundError = class extends BaseApiError {
  constructor(message, error, id) {
    super(404, "The requested resource does not exist.", "ResourceNotFound", message, error, id);
  }
};
var InvalidJsonSchemaError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The provided JSON schema is invalid.", "InvalidJsonSchema", message, error, id);
  }
};
var InvalidDataFormatError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The provided data doesn't respect the provided JSON schema.", "InvalidDataFormat", message, error, id);
  }
};
var InvalidIdentifierError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The provided identifier is not valid. An identifier must start with a lowercase letter, be between 2 and 100 characters long and use only alphanumeric characters.", "InvalidIdentifier", message, error, id);
  }
};
var RelationConflictError = class extends BaseApiError {
  constructor(message, error, id) {
    super(409, "The resource is related with a different resource that the one referenced in the request. This is usually caused when providing two resource identifiers that aren't linked together.", "RelationConflict", message, error, id);
  }
};
var ReferenceConstraintError = class extends BaseApiError {
  constructor(message, error, id) {
    super(409, "The resource cannot be deleted because it's referenced by another resource", "ReferenceConstraint", message, error, id);
  }
};
var ReferenceNotFoundError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The provided resource reference is missing. This is usually caused when providing an invalid id inside the payload of a request.", "ReferenceNotFound", message, error, id);
  }
};
var InvalidQueryError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "The provided query is invalid. This is usually caused when providing an invalid parameter for querying a resource.", "InvalidQuery", message, error, id);
  }
};
var RuntimeError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "An error happened during the execution of a runtime (bot or integration).", "Runtime", message, error, id);
  }
};
var AlreadyExistsError = class extends BaseApiError {
  constructor(message, error, id) {
    super(409, "The record attempted to be created already exists.", "AlreadyExists", message, error, id);
  }
};
var RateLimitedError = class extends BaseApiError {
  constructor(message, error, id) {
    super(429, "The request has been rate limited.", "RateLimited", message, error, id);
  }
};
var PaymentRequiredError = class extends BaseApiError {
  constructor(message, error, id) {
    super(402, "A payment is required to perform this request.", "PaymentRequired", message, error, id);
  }
};
var QuotaExceededError = class extends BaseApiError {
  constructor(message, error, id) {
    super(403, "The request exceeds the allowed quota. Quotas are a soft limit that can be increased.", "QuotaExceeded", message, error, id);
  }
};
var LimitExceededError = class extends BaseApiError {
  constructor(message, error, id) {
    super(413, "The request exceeds the allowed limit. Limits are a hard limit that cannot be increased.", "LimitExceeded", message, error, id);
  }
};
var BreakingChangesError = class extends BaseApiError {
  constructor(message, error, id) {
    super(400, "Request payload contains breaking changes which is not allowed for this resource without a version increment.", "BreakingChanges", message, error, id);
  }
};
var errorTypes = {
  Unknown: UnknownError,
  Internal: InternalError,
  Unauthorized: UnauthorizedError,
  Forbidden: ForbiddenError,
  PayloadTooLarge: PayloadTooLargeError,
  InvalidPayload: InvalidPayloadError,
  UnsupportedMediaType: UnsupportedMediaTypeError,
  MethodNotFound: MethodNotFoundError,
  ResourceNotFound: ResourceNotFoundError,
  InvalidJsonSchema: InvalidJsonSchemaError,
  InvalidDataFormat: InvalidDataFormatError,
  InvalidIdentifier: InvalidIdentifierError,
  RelationConflict: RelationConflictError,
  ReferenceConstraint: ReferenceConstraintError,
  ReferenceNotFound: ReferenceNotFoundError,
  InvalidQuery: InvalidQueryError,
  Runtime: RuntimeError,
  AlreadyExists: AlreadyExistsError,
  RateLimited: RateLimitedError,
  PaymentRequired: PaymentRequiredError,
  QuotaExceeded: QuotaExceededError,
  LimitExceeded: LimitExceededError,
  BreakingChanges: BreakingChangesError
};
var errorFrom = (err) => {
  if (isApiError(err)) {
    return err;
  } else if (err instanceof Error) {
    return new UnknownError(err.message, err);
  } else if (typeof err === "string") {
    return new UnknownError(err);
  } else {
    return getApiErrorFromObject(err);
  }
};
function getApiErrorFromObject(err) {
  if (typeof err === "object" && "code" in err && "type" in err && "id" in err && "message" in err && typeof err.type === "string" && typeof err.message === "string") {
    const ErrorClass = errorTypes[err.type];
    if (!ErrorClass) {
      return new UnknownError(`An unclassified API error occurred: ${err.message} (Type: ${err.type}, Code: ${err.code})`);
    }
    return new ErrorClass(err.message, void 0, err.id || "UNKNOWN");
  }
  return new UnknownError("An invalid error occurred: " + JSON.stringify(err));
}

// src/client.ts
var import_browser_or_node3 = require("browser-or-node");
var import_axios2 = __toESM(require("axios"));

// src/gen/client/index.ts
var import_qs = __toESM(require("qs"));
var import_axios = __toESM(require("axios"));

// src/gen/client/operations/getConversation.ts
var parseReq = (input) => {
  return {
    path: `/conversations/${encodeURIComponent(input["id"])}`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"] },
    body: {}
  };
};

// src/gen/client/operations/createConversation.ts
var parseReq2 = (input) => {
  return {
    path: `/conversations`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: {},
    body: { "id": input["id"] }
  };
};

// src/gen/client/operations/getOrCreateConversation.ts
var parseReq3 = (input) => {
  return {
    path: `/conversations/get-or-create`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: {},
    body: { "id": input["id"] }
  };
};

// src/gen/client/operations/deleteConversation.ts
var parseReq4 = (input) => {
  return {
    path: `/conversations/${encodeURIComponent(input["id"])}`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"] },
    body: {}
  };
};

// src/gen/client/operations/listConversations.ts
var parseReq5 = (input) => {
  return {
    path: `/conversations`,
    headers: { "x-user-key": input["x-user-key"] },
    query: { "nextToken": input["nextToken"] },
    params: {},
    body: {}
  };
};

// src/gen/client/operations/listenConversation.ts
var parseReq6 = (input) => {
  return {
    path: `/conversations/${encodeURIComponent(input["id"])}/listen`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"] },
    body: {}
  };
};

// src/gen/client/operations/listConversationMessages.ts
var parseReq7 = (input) => {
  return {
    path: `/conversations/${encodeURIComponent(input["id"])}/messages`,
    headers: { "x-user-key": input["x-user-key"] },
    query: { "nextToken": input["nextToken"] },
    params: { "id": input["id"] },
    body: {}
  };
};

// src/gen/client/operations/addParticipant.ts
var parseReq8 = (input) => {
  return {
    path: `/conversations/${encodeURIComponent(input["id"])}/participants`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"] },
    body: { "userId": input["userId"] }
  };
};

// src/gen/client/operations/removeParticipant.ts
var parseReq9 = (input) => {
  return {
    path: `/conversations/${encodeURIComponent(input["id"])}/participants/${encodeURIComponent(input["userId"])}`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"], "userId": input["userId"] },
    body: {}
  };
};

// src/gen/client/operations/getParticipant.ts
var parseReq10 = (input) => {
  return {
    path: `/conversations/${encodeURIComponent(input["id"])}/participants/${encodeURIComponent(input["userId"])}`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"], "userId": input["userId"] },
    body: {}
  };
};

// src/gen/client/operations/listParticipants.ts
var parseReq11 = (input) => {
  return {
    path: `/conversations/${encodeURIComponent(input["id"])}/participants`,
    headers: { "x-user-key": input["x-user-key"] },
    query: { "nextToken": input["nextToken"] },
    params: { "id": input["id"] },
    body: {}
  };
};

// src/gen/client/operations/getMessage.ts
var parseReq12 = (input) => {
  return {
    path: `/messages/${encodeURIComponent(input["id"])}`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"] },
    body: {}
  };
};

// src/gen/client/operations/createMessage.ts
var parseReq13 = (input) => {
  return {
    path: `/messages`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: {},
    body: { "payload": input["payload"], "conversationId": input["conversationId"] }
  };
};

// src/gen/client/operations/deleteMessage.ts
var parseReq14 = (input) => {
  return {
    path: `/messages/${encodeURIComponent(input["id"])}`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: { "id": input["id"] },
    body: {}
  };
};

// src/gen/client/operations/getUser.ts
var parseReq15 = (input) => {
  return {
    path: `/users/me`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: {},
    body: {}
  };
};

// src/gen/client/operations/createUser.ts
var parseReq16 = (input) => {
  return {
    path: `/users`,
    headers: {},
    query: {},
    params: {},
    body: { "name": input["name"], "pictureUrl": input["pictureUrl"], "profile": input["profile"], "id": input["id"] }
  };
};

// src/gen/client/operations/getOrCreateUser.ts
var parseReq17 = (input) => {
  return {
    path: `/users/get-or-create`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: {},
    body: { "name": input["name"], "pictureUrl": input["pictureUrl"], "profile": input["profile"] }
  };
};

// src/gen/client/operations/updateUser.ts
var parseReq18 = (input) => {
  return {
    path: `/users/me`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: {},
    body: { "name": input["name"], "pictureUrl": input["pictureUrl"], "profile": input["profile"] }
  };
};

// src/gen/client/operations/deleteUser.ts
var parseReq19 = (input) => {
  return {
    path: `/users/me`,
    headers: { "x-user-key": input["x-user-key"] },
    query: {},
    params: {},
    body: {}
  };
};

// src/gen/client/index.ts
var Client = class {
  constructor(axiosInstance) {
    this.axiosInstance = axiosInstance;
  }
  getConversation = async (input) => {
    const { path, headers, query, body } = parseReq(input);
    const axiosReq = toAxiosRequest({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  createConversation = async (input) => {
    const { path, headers, query, body } = parseReq2(input);
    const axiosReq = toAxiosRequest({
      method: "post",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  getOrCreateConversation = async (input) => {
    const { path, headers, query, body } = parseReq3(input);
    const axiosReq = toAxiosRequest({
      method: "post",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  deleteConversation = async (input) => {
    const { path, headers, query, body } = parseReq4(input);
    const axiosReq = toAxiosRequest({
      method: "delete",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  listConversations = async (input) => {
    const { path, headers, query, body } = parseReq5(input);
    const axiosReq = toAxiosRequest({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  listenConversation = async (input) => {
    const { path, headers, query, body } = parseReq6(input);
    const axiosReq = toAxiosRequest({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  listConversationMessages = async (input) => {
    const { path, headers, query, body } = parseReq7(input);
    const axiosReq = toAxiosRequest({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  addParticipant = async (input) => {
    const { path, headers, query, body } = parseReq8(input);
    const axiosReq = toAxiosRequest({
      method: "post",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  removeParticipant = async (input) => {
    const { path, headers, query, body } = parseReq9(input);
    const axiosReq = toAxiosRequest({
      method: "delete",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  getParticipant = async (input) => {
    const { path, headers, query, body } = parseReq10(input);
    const axiosReq = toAxiosRequest({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  listParticipants = async (input) => {
    const { path, headers, query, body } = parseReq11(input);
    const axiosReq = toAxiosRequest({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  getMessage = async (input) => {
    const { path, headers, query, body } = parseReq12(input);
    const axiosReq = toAxiosRequest({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  createMessage = async (input) => {
    const { path, headers, query, body } = parseReq13(input);
    const axiosReq = toAxiosRequest({
      method: "post",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  deleteMessage = async (input) => {
    const { path, headers, query, body } = parseReq14(input);
    const axiosReq = toAxiosRequest({
      method: "delete",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  getUser = async (input) => {
    const { path, headers, query, body } = parseReq15(input);
    const axiosReq = toAxiosRequest({
      method: "get",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  createUser = async (input) => {
    const { path, headers, query, body } = parseReq16(input);
    const axiosReq = toAxiosRequest({
      method: "post",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  getOrCreateUser = async (input) => {
    const { path, headers, query, body } = parseReq17(input);
    const axiosReq = toAxiosRequest({
      method: "post",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  updateUser = async (input) => {
    const { path, headers, query, body } = parseReq18(input);
    const axiosReq = toAxiosRequest({
      method: "put",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
  deleteUser = async (input) => {
    const { path, headers, query, body } = parseReq19(input);
    const axiosReq = toAxiosRequest({
      method: "delete",
      path,
      headers: { ...headers },
      query: { ...query },
      body
    });
    return this.axiosInstance.request(axiosReq).then((res) => res.data).catch((e) => {
      throw getError(e);
    });
  };
};
function getError(err) {
  if (import_axios.default.isAxiosError(err) && err.response?.data) {
    return errorFrom(err.response.data);
  }
  return errorFrom(err);
}
var isDefined = (pair) => pair[1] !== void 0;
var toAxiosRequest = (req) => {
  const { method, path: url, query, headers: headerParams, body: data } = req;
  const headerEntries = Object.entries(headerParams).filter(isDefined);
  const headers = Object.fromEntries(headerEntries);
  const queryString = import_qs.default.stringify(query, { encode: true, arrayFormat: "repeat", allowDots: true });
  const params = new URLSearchParams(queryString);
  return {
    method,
    url,
    headers,
    params,
    data
  };
};

// src/event-emitter.ts
var EventEmitter = class {
  listeners = {};
  emit(type, event) {
    const listeners = this.listeners[type];
    if (!listeners) {
      return;
    }
    for (const listener of [...listeners]) {
      listener(event);
    }
  }
  onceOrMore(type, listener) {
    const wrapped = (event) => {
      const status = listener(event);
      if (status === "stop-listening") {
        this.off(type, wrapped);
      }
    };
    this.on(type, wrapped);
  }
  once(type, listener) {
    const wrapped = (event) => {
      this.off(type, wrapped);
      listener(event);
    };
    this.on(type, wrapped);
  }
  on(type, listener) {
    if (!this.listeners[type]) {
      this.listeners[type] = [];
    }
    this.listeners[type].push(listener);
  }
  off(type, listener) {
    const listeners = this.listeners[type];
    if (!listeners) {
      return;
    }
    const index = listeners.indexOf(listener);
    if (index !== -1) {
      listeners.splice(index, 1);
    }
  }
  cleanup() {
    this.listeners = {};
  }
};

// src/eventsource.ts
var import_browser_or_node = require("browser-or-node");
var makeEventSource = (url, props = {}) => {
  if (import_browser_or_node.isBrowser) {
    const module3 = require("event-source-polyfill");
    const ctor = module3.EventSourcePolyfill;
    const source = new ctor(url, { headers: props.headers });
    const emitter = new EventEmitter();
    source.onopen = (ev) => emitter.emit("open", ev);
    source.onmessage = (ev) => emitter.emit("message", ev);
    source.onerror = (ev) => emitter.emit("error", ev);
    return {
      emitter,
      source
    };
  } else {
    const module3 = require("eventsource");
    const source = new module3(url, { headers: props.headers });
    const emitter = new EventEmitter();
    source.onopen = (ev) => emitter.emit("open", ev);
    source.onmessage = (ev) => emitter.emit("message", ev);
    source.onerror = (ev) => emitter.emit("error", ev);
    return {
      emitter,
      source
    };
  }
};
var listenEventSource = async (url, props = {}) => {
  const { emitter, source } = makeEventSource(url, props);
  await new Promise((resolve, reject) => {
    emitter.on("open", () => {
      resolve();
    });
    emitter.on("error", (thrown) => {
      reject(thrown);
    });
  }).finally(() => emitter.cleanup());
  return {
    on: emitter.on.bind(emitter),
    close: () => {
      emitter.cleanup();
      source.close();
    }
  };
};

// src/gen/signals/messageCreated.z.ts
var import_zod = require("zod");
var messageCreated_z_default = import_zod.z.object({
  type: import_zod.z.literal("message_created"),
  data: import_zod.z.object({
    id: import_zod.z.string(),
    createdAt: import_zod.z.string().datetime(),
    payload: import_zod.z.union([
      import_zod.z.object({ audioUrl: import_zod.z.string().min(1), type: import_zod.z.literal("audio") }),
      import_zod.z.object({
        title: import_zod.z.string().min(1),
        subtitle: import_zod.z.string().min(1).optional(),
        imageUrl: import_zod.z.string().min(1).optional(),
        actions: import_zod.z.array(
          import_zod.z.object({
            action: import_zod.z.enum(["postback", "url", "say"]),
            label: import_zod.z.string().min(1),
            value: import_zod.z.string().min(1)
          })
        ),
        type: import_zod.z.literal("card")
      }),
      import_zod.z.object({
        items: import_zod.z.array(
          import_zod.z.object({
            title: import_zod.z.string().min(1),
            subtitle: import_zod.z.string().min(1).optional(),
            imageUrl: import_zod.z.string().min(1).optional(),
            actions: import_zod.z.array(
              import_zod.z.object({
                action: import_zod.z.enum(["postback", "url", "say"]),
                label: import_zod.z.string().min(1),
                value: import_zod.z.string().min(1)
              })
            )
          })
        ),
        type: import_zod.z.literal("carousel")
      }),
      import_zod.z.object({
        text: import_zod.z.string().min(1),
        options: import_zod.z.array(
          import_zod.z.object({
            label: import_zod.z.string().min(1),
            value: import_zod.z.string().min(1)
          })
        ),
        type: import_zod.z.literal("choice")
      }),
      import_zod.z.object({
        text: import_zod.z.string().min(1),
        options: import_zod.z.array(
          import_zod.z.object({
            label: import_zod.z.string().min(1),
            value: import_zod.z.string().min(1)
          })
        ),
        type: import_zod.z.literal("dropdown")
      }),
      import_zod.z.object({
        fileUrl: import_zod.z.string().min(1),
        title: import_zod.z.string().min(1).optional(),
        type: import_zod.z.literal("file")
      }),
      import_zod.z.object({ imageUrl: import_zod.z.string().min(1), type: import_zod.z.literal("image") }),
      import_zod.z.object({
        latitude: import_zod.z.number(),
        longitude: import_zod.z.number(),
        address: import_zod.z.string().optional(),
        title: import_zod.z.string().optional(),
        type: import_zod.z.literal("location")
      }),
      import_zod.z.object({
        markdown: import_zod.z.string().min(1),
        type: import_zod.z.literal("markdown")
      }),
      import_zod.z.object({ text: import_zod.z.string().min(1), type: import_zod.z.literal("text") }),
      import_zod.z.object({ videoUrl: import_zod.z.string().min(1), type: import_zod.z.literal("video") })
    ]),
    userId: import_zod.z.string(),
    conversationId: import_zod.z.string()
  })
});

// src/gen/signals/index.ts
var zod = {
  messageCreated: messageCreated_z_default
};

// src/signal-listener.ts
var DEFAULT_ERROR_MESSAGE = "unknown error";
var _SignalListener = class extends EventEmitter {
  constructor(_props) {
    super();
    this._props = _props;
  }
  _state = { status: "disconnected" };
  get status() {
    return this._state.status;
  }
  connect = async () => {
    if (this._state.status === "connected") {
      return;
    }
    if (this._state.status === "connecting") {
      await this._state.connectionPromise;
      return;
    }
    const connectionPromise = this._connect();
    this._state = { status: "connecting", connectionPromise };
    await connectionPromise;
  };
  disconnect = async () => {
    if (this._state.status === "disconnected") {
      return;
    }
    let source;
    if (this._state.status === "connecting") {
      source = await this._state.connectionPromise;
    } else {
      source = this._state.source;
    }
    this._disconnectSync(source);
  };
  _connect = async () => {
    const source = await listenEventSource(`${this._props.url}/conversations/${this._props.conversationId}/listen`, {
      headers: { "x-user-key": this._props.userKey }
    });
    source.on("message", this._handleMessage);
    source.on("error", this._handleError(source));
    this._state = { status: "connected", source };
    return source;
  };
  _disconnectSync = (source) => {
    source.close();
    this._state = { status: "disconnected" };
  };
  _handleMessage = (ev) => {
    const signal = this._parseSignal(ev.data);
    this.emit(signal.type, signal.data);
  };
  _handleError = (source) => (ev) => {
    this._disconnectSync(source);
    const err = this._toError(ev);
    this.emit("error", err);
  };
  _parseSignal = (data) => {
    for (const schema of Object.values(zod)) {
      const parsedData = this._safeJsonParse(data);
      const parseResult = schema.safeParse(parsedData);
      if (parseResult.success) {
        return parseResult.data;
      }
    }
    return {
      type: "unknown",
      data
    };
  };
  _safeJsonParse = (x) => {
    try {
      return JSON.parse(x);
    } catch {
      return x;
    }
  };
  _toError = (thrown) => {
    if (thrown instanceof Error) {
      return thrown;
    }
    if (typeof thrown === "string") {
      return new Error(thrown);
    }
    if (thrown === null) {
      return new Error(DEFAULT_ERROR_MESSAGE);
    }
    if (typeof thrown === "object" && "message" in thrown) {
      return this._toError(thrown.message);
    }
    try {
      const json = JSON.stringify(thrown);
      return new Error(json);
    } catch {
      return new Error(DEFAULT_ERROR_MESSAGE);
    }
  };
};
var SignalListener = _SignalListener;
__publicField(SignalListener, "listen", async (props) => {
  const inst = new _SignalListener(props);
  await inst.connect();
  return inst;
});

// src/jsonwebtoken.ts
var import_browser_or_node2 = require("browser-or-node");
var requireJwt = () => require("jsonwebtoken");
var module2 = import_browser_or_node2.isBrowser ? null : requireJwt();
var jsonwebtoken_default = module2;

// src/client.ts
var _100mb = 100 * 1024 * 1024;
var maxBodyLength = _100mb;
var maxContentLength = _100mb;
var defaultTimeout = 6e4;
var _createAuthClient = Symbol("_createAuthClient");
var _Client = class {
  constructor(props) {
    this.props = props;
    const axiosClient = _Client._createAxios(props);
    this._auto = new Client(axiosClient);
  }
  _auto;
  static async connect(props) {
    const { userId, userKey, encryptionKey, ...clientProps } = props;
    const client = new _Client(clientProps);
    if (userKey) {
      const { user: user2 } = await client.getOrCreateUser({ "x-user-key": userKey });
      return AuthenticatedClient[_createAuthClient](client, { ...user2, key: userKey });
    }
    if (userId && encryptionKey) {
      if (!jsonwebtoken_default) {
        const message = "Connecting with an encryption key is not supported in the browser; use in NodeJs or format the key manually with jsonwebtoken.";
        throw new Error(message);
      }
      const userKey2 = jsonwebtoken_default.sign({ id: userId }, encryptionKey, { algorithm: "HS256" });
      const { user: user2 } = await client.getOrCreateUser({ "x-user-key": userKey2 });
      return AuthenticatedClient[_createAuthClient](client, { ...user2, key: userKey2 });
    }
    const { user, key } = await client.createUser({ id: userId });
    return AuthenticatedClient[_createAuthClient](client, { ...user, key });
  }
  createConversation = (x) => this._auto.createConversation(x);
  getConversation = (x) => this._auto.getConversation(x);
  getOrCreateConversation = (x) => this._auto.getOrCreateConversation(x);
  deleteConversation = (x) => this._auto.deleteConversation(x);
  listConversations = (x) => this._auto.listConversations(x);
  listConversationMessages = (x) => this._auto.listConversationMessages(x);
  addParticipant = (x) => this._auto.addParticipant(x);
  removeParticipant = (x) => this._auto.removeParticipant(x);
  getParticipant = (x) => this._auto.getParticipant(x);
  listParticipants = (x) => this._auto.listParticipants(x);
  createMessage = (x) => this._auto.createMessage(x);
  getMessage = (x) => this._auto.getMessage(x);
  deleteMessage = (x) => this._auto.deleteMessage(x);
  createUser = (x) => this._auto.createUser(x);
  getUser = (x) => this._auto.getUser(x);
  getOrCreateUser = (x) => this._auto.getOrCreateUser(x);
  updateUser = (x) => this._auto.updateUser(x);
  deleteUser = (x) => this._auto.deleteUser(x);
  listenConversation = async ({ id, "x-user-key": userKey }) => {
    const signalListener = await SignalListener.listen({
      url: this.props.apiUrl,
      conversationId: id,
      userKey
    });
    return signalListener;
  };
};
var Client2 = _Client;
__publicField(Client2, "_createAxios", (props) => {
  const headers = {
    ...props.headers
  };
  const timeout = props.timeout ?? defaultTimeout;
  const withCredentials = import_browser_or_node3.isBrowser;
  const { apiUrl: baseURL } = props;
  return import_axios2.default.create({
    baseURL,
    headers,
    withCredentials,
    timeout,
    maxBodyLength,
    maxContentLength,
    validateStatus: (status) => status >= 200 && status < 400
  });
});
var _a;
var _AuthenticatedClient = class {
  constructor(_client, user) {
    this._client = _client;
    this.user = user;
  }
  createConversation = (x) => this._client.createConversation({ "x-user-key": this.user.key, ...x });
  getConversation = (x) => this._client.getConversation({ "x-user-key": this.user.key, ...x });
  getOrCreateConversation = (x) => this._client.getOrCreateConversation({ "x-user-key": this.user.key, ...x });
  deleteConversation = (x) => this._client.deleteConversation({ "x-user-key": this.user.key, ...x });
  listConversations = (x) => this._client.listConversations({ "x-user-key": this.user.key, ...x });
  listConversationMessages = (x) => this._client.listConversationMessages({ "x-user-key": this.user.key, ...x });
  listenConversation = (x) => this._client.listenConversation({ "x-user-key": this.user.key, ...x });
  addParticipant = (x) => this._client.addParticipant({ "x-user-key": this.user.key, ...x });
  removeParticipant = (x) => this._client.removeParticipant({ "x-user-key": this.user.key, ...x });
  getParticipant = (x) => this._client.getParticipant({ "x-user-key": this.user.key, ...x });
  listParticipants = (x) => this._client.listParticipants({ "x-user-key": this.user.key, ...x });
  createMessage = (x) => this._client.createMessage({ "x-user-key": this.user.key, ...x });
  getMessage = (x) => this._client.getMessage({ "x-user-key": this.user.key, ...x });
  deleteMessage = (x) => this._client.deleteMessage({ "x-user-key": this.user.key, ...x });
  getUser = (x) => this._client.getUser({ "x-user-key": this.user.key, ...x });
  updateUser = (x) => this._client.updateUser({ "x-user-key": this.user.key, ...x });
  deleteUser = (x) => this._client.deleteUser({ "x-user-key": this.user.key, ...x });
};
var AuthenticatedClient = _AuthenticatedClient;
_a = _createAuthClient;
__publicField(AuthenticatedClient, _a, (client, user) => {
  return new _AuthenticatedClient(client, user);
});
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  AlreadyExistsError,
  AuthenticatedClient,
  BreakingChangesError,
  Client,
  ForbiddenError,
  InternalError,
  InvalidDataFormatError,
  InvalidIdentifierError,
  InvalidJsonSchemaError,
  InvalidPayloadError,
  InvalidQueryError,
  LimitExceededError,
  MethodNotFoundError,
  PayloadTooLargeError,
  PaymentRequiredError,
  QuotaExceededError,
  RateLimitedError,
  ReferenceConstraintError,
  ReferenceNotFoundError,
  RelationConflictError,
  ResourceNotFoundError,
  RuntimeError,
  SignalListener,
  UnauthorizedError,
  UnknownError,
  UnsupportedMediaTypeError,
  axios,
  errorFrom,
  isApiError
});
//# sourceMappingURL=index.cjs.map
